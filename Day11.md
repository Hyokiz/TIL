# 20220726 TIL

## 오전 복습

> 컨테이너의 분류

- 컨테이너 == 변수의 저장
- 문자열 == 시퀀스형
- 컨테이너 전부 for문으로 반복 가능 == iterable
- 가변형(mutable) == 리스트, 세트, 딕셔너리
- 불변형(immutable) == 튜플, 레인지
- 가변형, 불변형 특성은 중요함.
- list, set, dict == mutable
- bool, int, float, tuple, str, range == immutable
  
> 함수와 메서드

- 함수 == 모든 자료형에 사용 가능
- 메서드 == 특정 자료형에 사용 가능

> 문자열은 immutable인데, 문자열 변경이 되는 이유?

- 새로운 문자열로 반환하는 것 뿐. 원래의 문자열은 남아 있다.

> 얕은 복사와 깊은 복사

1. 할당
2. 얕은 복사
3. 깊은 복사

> 할당

```python
a = [1, 2, 3]
b = a # b도 [1. 2. 3] 을 담음.
print(a, b) # [1, 2, 3] [1, 2, 3]
b[0] = 4
print(a, b) # [4, 2, 3] [4, 2, 3]
```
- 변수는 포스트잇이다. 값이 있으면 a, b가 포스트잇처럼 값에 붙는 것이다.(C언어 = 포인터)
  
```python
a = "hello"
b = a
a += "Python"
print(a, b) # helloPython hello
```
- mutable은 가변형이므로 a와 b가 같이 변하지만, immutable은 불변형이므로 a와 b가 같이 변하지 않는다.

> 얕은 복사

```python
a = [1, 2, 3]
b = a[:] # a와 똑같은 모양의 리스트를 생성
b[0] = 4
print(a, b) # [1, 2, 3] [4, 2, 3]
b = list(a) # b = a[:] 와 같은 의미
```

```python
a = [1, 2, [5, 6]]
b = a[:]
print(a, b) # [1, 2, [5, 6]] [1, 2, [5, 6]]
a[2][0] = 7
print(a, b) # [1, 2, [7, 6]] [1, 2, [7, 6]]
# 왜 같이 바뀔까?
# 리스트 안의 리스트는 같은 값을 가진다.
# 얕은 복사 = 리스트만 복사, 리스트 안의 리스트는 복사 X
```

> 깊은 복사

```python
import copy
a = [1, 2, [5, 6]]
b = copy.deepcopy(a)
a[2][0] = 7
print(a, b) # [1, 2, [7, 6]] [1, 2, [5, 6]]
```

> 예시

```python
a =[[0] * 3] * 3] # [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
a[0][0] = 1
print(a) # [[1, 0, 0], [1, 0, 0], [1, 0, 0]]

a = [[0] * 3 for i in range(3)]
print(a) # [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
a[0][0] = 1
print(a) # [[1, 0, 0], [0, 0, 0], [0, 0, 0]]
# [0] * 3은 *를 해도 되는 이유 == int는 immutable이기 때문에.
```
