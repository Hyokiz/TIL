# 20230119 TIL

# 1. WebRTC

- Web Real-Time Communication의 약자
- 웹, 앱에서 별다른 소프트웨어 없이 카메라, 마이크 등 실시간 커뮤니케이션 제공
- 화상통화, 화상공유
- P2P방식
- JavaScript API
- 알아야할 용어
    - data streams, STUN/TURN servers, signaling, JSEP, ICE, SIP, SDP, NAT, UDP/TCP, network socket

# 2. WebRTC 장점과 단점

## 장점

1. Latency가 짧다.(지연시간)
    - 우리가 흔히 알고 있는 RTMP(Real Time Messaging Protocol)를 사용하여 실시간 스트리밍을 하고 있다.
2. 별 다른 소프트웨어 없이 실시간 커뮤니티가 가능하다.
3. 개발하는 데 있어 진입 장벽이 낮다.
4. 무료다.

## 단점

1. 크로스 브라우징 문제
2. STUN/TURN 서버 필요

# 단어 정리

## NAT(Network Address Translation)

NAT은 Private IP를 Public IP로 1대1 대응시켜 변환하는 장치를 말한다.

통상적인 네트워크에서 데이터를 주고 받기 위해서는 Public IP가 필요한데, NAT이 IP주소를 재기록 하면서 라우터를 통해 네트워크 트래픽을 주고 받는 메커니즘이다.

WebRTC 통신은 Peer to Peer 방식으로 서로 데이터를 주고 받아야 하기 때문에 보내고 받는 Peer 의 Public IP를 알고 있어야 한다.

현대의 네트워크 세상에선 NAT와 방화벽을 제외하고는 설명될 수 없다.

이것은 STUN, TURN 서버를 사용해서 문제를 해결할 수 있다.

## ICE(Interactive Connectivity Establishment)

ICE는 두 단말이 서로 통신할 수 있는 최적의 경로를 찾을 수 있도록 도와주는 프레임워크이다.

### 어떻게 최적의 경로를 찾을 수 있을까?

TURN, STUN 서버를 사용하여 최적의 경로를 찾을 수 있다.

## 왜 ICE를 사용해야 하는가?

모든 단말은 각자의 환경(학교 내부망, 회사 내부망, 집 네트워크 등)이 다양하기 때문에 단순하게 연결되지 않음.

방화벽이 존재하는 환경에서는 방화벽을 통과해야 하고 단말의 Public IP가 없다면 유일한 주소값을 할당해야 하고 라우터가 Peer간의 직접 연결을 허용하지 않을 때에는 데이터를 릴레이 해야 한다.

ICE 프로세스를 사용하면 NAT가 통신을 위해 필요한 모든 포트를 열어두고 두 엔드 포인트 모두 다 연결할 수 있는 IP주소, 포트에 대한 완전한 정보를 갖게 된다.

결국, 요청하는 클라이언트와 미디어 서버 사이의 연결을 통해 미디어(비디오, 음성) 등을 주고 받을 수 있다는 것이다.

ICE 혼자는 작동하지 않으며 STUN과 TURN서버를 사용해야 한다.

## STUN(Session Traversal Utilities for NAT)

공개 주소를 발견하거나 peer 간의 직접 연결을 막는 등 라우터의 제한을 결정하며, ICE를 보완하는 프로토콜이다. 간단하게 말하면 STUN 서버는 **해당 Peer의 공인 IP주소를 보내는 역할**을 한다.

STUN은 두 엔드 포인트 간의 연결을 확인하고 NAT 바인딩을 유지하기 위한 연결 유지 프로토콜로도 사용할 수 있다.

단점으로는, 두 단말이 같은 NAT 환경에 있을 경우 또는 NAT의 보안정책이 엄격하거나 등의 이유에 따라 STUN이 완벽한 해결책이 되지는 않는다.

## TURN(Traversal Using Relays around NAT)

STUN의 확장으로 NAT 환경에서 릴레이하여 통신을 하게 된다.

NAT 보안 정책이 너무 엄격하거나 NAT 순회를 하기 위해 필요한 NAT 바인딩을 성공적으로 생성할 수 없는 경우에 TURN을 사용한다.

TURN 서버는 인터넷망에 위치하고 각 Peer(단말)들이 사설망(Private IP)안에서 통신한다. 각 Peer 들이 직접 통신하는 것이 아니라 릴레이 역할을 하는 TURN 서버를 사용하여 경유한다.

TURN은 이러한 릴레이로부터 IP주소와 포트를 클라이언트가 취득할 수 있는 릴레이 주소를 할당한다.

단점으로는 클라이언트와의 연결을 거의 항상 제공하지만 STUN에 비해 리소스 낭비가 심하다. 그렇기 때문에 ICE Candidate과정에서 local IP로 연결할 수 있는지, Public IP로 연결할 수 있는지를 알아낸 후 최후의 수단으로 사용해야 한다.

## ICE Candidate Gathering

Local Address(클라이언트의 사설 주소, Private IP, Port), Server Reflexive Address(NAT가 매핑한 클라이언트의 공인망, Public IP, Port), Relayed Address(Turn 서버가 패킷 릴레이를 위해 할당하는 주소) 등 통신 가능한 주소들을 모두 가져온다. 이 주소들 중 가장 최적의 경로를 찾아서 연결시켜준다.

## Signaling Server

P2P 접속 정보를 주고 받을 수 있도록, 중계 해주는 서버

---

# OpenVidu

## OpenVidu 애플리케이션 아키텍처

세 부분으로 구성

- OpenVidu 배포 : 실시간 오디오 및 비디오 스트리밍에 필요한 모든 인프라 제공. 애플리케이션에서 배포하고 사용하기만 하면 됨.
- 서버 응용 프로그램 : OpenVidu에서 제공하는 REST API 사용. 이러한 방식으로 세션, 연결을 생성하고 화상 통화를 안전하게 관리
- 클라이언트 애플리케이션 : 웹 브라우저, 모바일, 데스크톱에서 실행.

## 기본 개념

### 세션

참가자가 연결하여 오디오 및 비디오 스트림을 보내고 받을 수 있는 가상 공간. 동일한 세션 참가자들만 서로 보고 들을 수 있음.

### 연결

세션의 각 참가자. 세션에 연결하려면 응용 프로그램 서버에서 초기화해야 하며 해당 토큰을 응용 프로그램 클라이언트에 전달해야 한다. 권한 없으면 연결할 수 없음. 연결은 세션에 연결하는 클라이언트의 슬롯으로도 볼 수 있음. 응용 프로그램 서버에서 슬롯을 초기화하면 연결된 토큰을 사용하여 클라이언트가 해당 슬롯을 차지할 수 있음. 클라이언트가 연결을 점유하면 세션의 참가자로 간주.

### 토큰

참가자에게 세션에 대한 액세스 권한 부여. 각 참가자는 세션에 연결할 때 토큰을 사용함. 토큰은 항상 연결에 필요함. 클라이언트에 전달할 토큰을 얻으려면 응용 프로그램 서버에서 연결을 생성해야 함. 애플리케이션 클라이언트에서 사용될 때 토큰은 세션 내부의 참가자에게 메타데이터 및 특정 기능 제공

### 스트림

스트림은 세션으로 흐르는 미디어 스트림. 참가자는 스트림을 게시할 수 있으며 동일한 세션의 다른 참가자는 스트림을 구독할 수 있음. 세션에서 게시할 수 있는 방법, 시기, 사람 및 유형에 따른 제한은 없음. 이는 전적으로 애플리케이션과 사용 사례에 따라 다름

## OpenVidu 세션의 WorkFlow

1. 애플리케이션 서버에서 세션 초기화
2. 응용 프로그램 서버에서 세션에 대한 연결 생성.
3. 세션에 연결할 수 있도록 클라이언트에 토큰 전달.
4. 토큰을 사용하여 openvidu-browser.js를 사용하여 세션 연결.
5. 스트림 게시

---

# HTTP의 한계

`사용자가 URL을 요청할 때`에만 해당 페이지를 꺼내줌.

문제를 해결하기 위해 AJAX 등장

# AJAX(Asynchronous Javascript And Xml)

비동기적인 자바스크립트로 DOM을 읽고 쓰며 XMLHttpRequest 객체를 통해 서버와 데이터를 주고 받음

유저는 새로운 HTML을 서버로부터 받는 것이 아닌, 동일한 웹페이지 내에서 DOM을 변경하게 됨.

1. 요청 페이지에서 이름에 “촉새”, 내용에 “안녕하세요. 촉새입니다”라고 씀
2. 사용자의 이벤트로부터 JavaScript는 해당 이름과 내용이 쓰여진 DOM을 읽음
3. XMLHttpRequest 객체를 통해 웹서버에 해당 이름과 내용을 전송
4. 웹 서버는 요청을 처리하고 XML, Text 혹은 JSON을 XMLHttpRequest 객체에 전송
5. JavaScript가 해당 응답 정보를 DOM에 씀.
6. 결과페이지

### XMLHttpRequest

서버와 상호작용 할때 사용하는 객체

AJAX로 아이디 중복 체크도 가능

**아이디를 중복체크 하려면 서버쪽 DB와 통신하기 위해서 웹 서버 동작이 필요한데, 이때 페이지를 바꾸지 않고 요청 결과만 그대로 가져와서 띄우면 됨**

# 정리

AJAX는 페이지 전체를 리로딩 하지 않고 웹 페이지 일부분만을 갱신할 수 있음.

즉, AJAX를 이용하면 백그라운드 영역에서 서버와 통신하여 그 결과를 웹 페이지의 일부분에만 표시할 수 있음.

# HTTP vs AJAX

## 페이지의 변경

### HTTP

페이지 전체를 갱신

### AJAX

필요한 데이터만 갱신

## 서버로의 요청

### HTTP

웹브라우저가 서버에 요청

### AJAX

XMLHttpRequest 객체가 서버에 요청

## 페이지의 이동

### HTTP

항상 페이지 이동

### AJAX

해당 페이지 내에서 변경

# AJAX의 한계

AJAX도 여전히 HTTP로 서버와 통신하기 때문.

HTTP는 `클라이언트의 요청이 있고 그 다음 서버로부터 응답을 받는 상황`

그 틀로부터 아직 벗어나지 못함.

이러한 애로사항이 HTML5 개발 과정에 녹아들게 됨

결국, HTML5은 순수 웹 환경에서 실시간 양방향 통신이 가능하게 만들어졌는데,

그것이 `웹 소켓(Web Socket)` 입니다.

## HTTP 와 HTTPS 의 차이

S는 Secured의 S

웹페이지를 요청하는 사람이 무슨 페이지를 요청하는지, 서버가 유저에게 어떤 페이지를 주었는지 암호화.

정부가 불법 사이트를 없애지 못하는 이유도 S 때문

---

# 웹 소켓이란?

웹 소켓은 HTML5 표준 기술.

**브라우저와 서버 사이의 동적인 양방향 연결 채널을 구성**

웹소켓은 단순한 API로 구성되어 있음.

하나의 HTTP 접속으로 양방향 메세지를 주고받을 수 있음

# HTTP vs 웹 소켓

지금까지 통신했던 방법과 WebSocket의 차이는 `프로토콜`

WebSocket 프로토콜은 **적솝 확립에 HTTP 사용**

그 후의 통신은 **WebSocket 독자의 프로토콜**