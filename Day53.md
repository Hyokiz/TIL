# 20220921 TIL

## 완전 검색, 그리디

> 반복(Iteration)과 재귀(Recursion)

- 반복과 재귀는 유사한 작업
- 반복은 수행하는 작업이 완료될 때 까지 계속 반복

  - 루프(for, while)

- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법

  - 하나의 큰 문제를 해결할 수 있는 더 작은 문제로 쪼개고 결과들을 결합한다.
  - 재귀 함수로 구현

> 반복구조

- 초기화

  - 반복되는 명령문 실행 전 조건 검사에 사용할 변수의 초기값 설정

- 조건 검사

- 반복할 명령문 실행

- 업데이트

  - 무한 루프가 되지 않게 조건을 False로

> 재귀 함수

- 함수 내부에서 직접 또는 간접적으로 자기 자신 호출
- 재귀적 정의를 이용해서 재귀 함수 구현
- 기본 부분, 유도 부분으로 구성
- 반복 구조에 비해 간결하고 이해하기 쉽다.

  - 재귀에 익숙하지 않으면 어렵다고 느낌

- 함수 호출은 메모리 구조에서 스택을 사용. 메모리 및 속도에서 성능 저하 발생

> 반복 또는 재귀?

- 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스러움

  - 추상 자료형(List, tree 등)의 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우가 많다.

- 일반적으로, 재귀적 알고리즘은 반복 알고리즘보다 더 많은 메모리와 연산을 필요로 한다.

- 입력 값이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.

> 완전 검색

- 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것이다.
- 순열(permutation), 조합(combination), 부분집합(subsets), 조합적 문제들(combinatorial problems)과 연관된다.

## 부분 집합

- 집합에 포함된 원소들을 선택

> 부분 집합 생성 방법

- 바이너리 카운팅을 통한 사전적 순서(Lexicographic Order)

  - 가장 자연스러운 방법

- 바이너리 카운팅

  - 원소 수가 해당하는 N개의 비트열을 이용한다.
  - n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미

## 조합

- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것을 조합(combination)

## 탐욕 알고리즘

- 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근
- 각 선택 지점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 해답을 만들었어도 그것이 최적이라는 보장은 없다.
- 최적화 문제(optimization)란 가능한 해들 중에서 가장 좋은 해를 찾는 문제이다.

> 탐욕 알고리즘의 동작 과정

1. 해 선택

- 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 부분해 집합에 추가

2. 실행 가능성 검사

- 새로운 부분 해 집합이 실행 가능한지 확인. 문제의 제약 조건을 위반하지 않는 지 검사

3. 해 검사

- 새로운 부분 해 집합이 문제의 해가 되는지 확인. 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작.

> 배낭 짐싸기(Knapsack)

- 도둑은 훔친 물건을 배낭에 담아올 계획. 배낭에 담을 수 있는 총 무게(W)가 정해져 있다.
- 창고에는 여러 개(n)개의 물건들이 있고, 무게와 값이 정해져 있다.
- 배낭이 수용할 수 있는 무게를 초과하지 않으면서, 값이 최대가 되도록 담아야 한다.

- Knapsack 문제 유형

  - 0-1 Knapsack

    - 배낭에 물건을 통째로 담아야 하는 문제
    - 물건을 쪼갤 수 없는 경우

  - Fractional Knapsack
    - 물건을 부분적으로 담는 것이 허용되는 문제
    - 물건을 쪼갤 수 있는 경우

> 0-1 Knapsack에 대한 완전 검색 방법

- 완전 검색으로 물건들의 집합 S에 대한 모든 부분집합 구한다.
- 부분집합의 총 무게가 W를 초과하는 집합들은 버리고 나머지 집합에서 총 값이 가장 큰 값 선택
- 물건 개수 증가 시 시간 복잡도가 지수적으로 증가

1. 값이 비싼 물건부터

- 최적이 아니다

2. 값이 싼 물건부터

- 최적이 아니다

3. 무게 당 값이 높은 순서로 물건을 채운다

- 최적이 아니다

> Fractional Knapsack 문제

- 물건의 일부를 잘라서 담을 수 있다.

- 탐욕적인 방법

  - 최적해 구할 수 있다.

> 탐욕 알고리즘 필수 요소

- 탐욕적 선택 속성

  - 탐욕적 선택은 최적해로 갈 수 있음을 보여라

    - 항상 안전하다

- 최적 부분 구조

  - 최적화 문제를 정형화하라.

    - 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다

- 원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해 임을 증명

> 탐욕 기법과 동적 계획법의 비교

- 탐욕 기법

  - 매 단계에서 가장 좋게 보이는 것 선택 > 지역 최적 선택
  - 하위 문제를 풀기 전 탐욕적 선택이 먼저
  - Top-down 방식
  - 일반적으로 빠르고 간결

- 동적 계획법

  - 매 단계의 선택은 해결한 하위 문제의 해 기반
  - 하위 문제가 우선 해결
  - Bottom-up 방식
  - 좀더 느리고 복잡

> 대표적인 탐욕 기법의 알고리즘들

- Prim, Kruskal, Dijkstra, Huffman tree and code
