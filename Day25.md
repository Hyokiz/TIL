# 20220810 TIL

## 2차원 배열

> 2차원 배열의 선언

- 1차원 List 를 묶어놓은 List
- 2차원 이상의 다차원 List는 차원에 따라 Index를 선언
- 2차원 List의 선언 : 세로 길이(행의 개수), 가로 길이(열의 개수)를 필요로 함
- Python 에서는 데이터 초기활르 통해 변수 선언과 초기화가 가능

- arr = [[0, 1, 2, 3], [4, 5, 6, 7]] (2행 4열의 2차원 List)

```python
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]
# 3
# 1 2 3
# 4 5 6
# 7 8 9

N = int(input())
arr = [list(map(int, input())) for _ in range(N)]
# 3
# 123
# 456
# 789

for i in range(N):
    for j in range(N):
        print(arr[i][j], end=' ')
    print()
# 1 2 3
# 4 5 6
# 7 8 9

for i in range(len(arr)):
    for j in range(len(arr[0])):
        print(arr[i][j], end=' ')
    print()
```

> 배열 순회

- n x m 배열의 n\*m개의 모든 원소를 빠짐없이 조사하는 방법

> 행 우선 순회

```python
# i행의 좌표
# j행의 좌표
for i in range(n):
    for j in range(m): # 2차원 배열의 모든 원소에 대해
        arr[i][j] # 필요한 연산 수행
```

> 열 우선 순회

```python
# i행의 좌표
# j행의 좌표

for j in range(m):
    for i in range(n):
        arr[i][j] # 필요한 연산 수행

for i in range(n):
    for j in range(m):
        arr[j][i] # 이것도 가능
```

> 지그재그 순회

```python
# i행의 좌표
# j열의 좌표

for i in range(n):
    for j in range(m):
        arr[i][j + (m-1-2*j) * (i%2)]
        # 거꾸로 순회하기 위해서는 m-1-j가 되야 한다.
        # 짝수행일때는 j가 증가하면서 순회해야 하므로 i%2를 0으로 만들어 뒤에 식을 삭제한다.
        # 홀수행일 때는 j가 감소하면서 순회해야 하므로 i%2는 1이 되고
        # j가 남아 있으므로 m-1-j를 만드려면 m-1-2j를 더해준다.
```

> 델타를 이용한 2차 배열 탐색

- 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법

```python
# 4방향의 인접 배열 요소 탐색 방법
arr[0 ... N-1][0 ... N-1] # NxN 배열
di[] = [0, 0, -1, 1] # 상하
dj[] = [-1, 1, 0, 0] # 좌우
for i : 1 > N-1
    for j : 1 > N-1:
        ni < i + di[k]
        nj < j + dj[k]
        if 0 <= ni < N and 0 <= nj < N # 유효한 인덱스면
            test(arr[ni][nj])
```

> 전치 행렬

```python
# i : 행의 좌표, len(arr)
# j : 열의 좌표, len(arr[0])
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # 3 * 3 행렬

for i in range(3):
    for j in range(3):
        if i < j:
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```

## 부분집합

> 부분집합 합 문제

- 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제

- 예를 들어, [-7, -3, -2, 5, 8]라는 집합이 있을 때, [-3, 2, 5]는 이 집합의 부분집합이면서 (-3)+(-2)+5 = 0이므로 이 경우의 답은 참

> 부분집합 생성하기

- 완전검색 기법으로

> 부분집합의 수

- 집합의 원소가 n개 일때, 공집합을 포함한 부분집합의 수는 2^n개
- 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 경우 2가지 경우를 모든 원소의 수에 적용한 경우의 수와 같다.

> 각 원소가 부분집합에 포함되었는지를 loop 이용하여 확인하고 부분집합을 생성하는 방법

```python

```

> 비트연산자

- & : 비트 단위로 and 연산을 한다.
- | : 비트 단위로 or 연산을 한다.
- << : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
- \>> : 피연산자의 비트 열을 오른쪽으로 이동시킨다.

- <<연산자

  - 1 << n : 2^n 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.

- & 연산자

  - i & (1\<<j) : i의 j번째 비트가 1인지 아닌지를 검사한다.

> 보다 간결하게 부분집합을 생성하는 방법

```python

arr = [3, 6, 7, 1, 5, 4]

n = len(arr)

for i in range(1<<n): # 1<<n : 부분 집합의 개수
    for j in range(n): # 원소의 수만큼 비트를 비교함
        if i & (1<<j): # i의 j번 비트가 1인경우
            print(arr[j], end=', ') # j번 원소 출력
    print()
print()
```

## 검색

- 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업

- 목적하는 탐색 키를 가진 항목을 찾는 것

  - 탐색 키(search key) : 자료를 구별하여 인식할 수 있는 키

- 검색의 종류
  - 순차 검색(sequential search)
  - 이진 검색(binary search)
  - 해쉬(hash)

> 순차 검색

- 일렬로 되어 있는 자료를 순서대로 검색하는 방법

  - 가장 간단하고 직관적
  - 배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 학목을 찾을 때 유용

- 2가지 경우
  - 정렬되어있지 않은 경우
  - 정렬되어있는 경우

> 정렬되어있지 않은 경우

- 검색 과정

  - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.
  - 키 값이 동일한 원소를 찾으면 그 원소의 인덱스 반환
  - 마지막까지 찾지 못하면 검색 실패

- 찾고자 하는 원소의 순서에 따라 비교회수 결정
  - 정렬되지 않은 자료에서의 순차 검색의 평균 비교 회수
    - (1/n) \* (1+2+3+...+n) = (n+1)/2
  - 시간 복잡도 : O(n)

> 정렬되어 있는 경우

- 자료가 오름차순으로 정렬된 상태에서 검색 가정
- 순차적으로 검색하면서 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 것이므로 검색 종료
- 찾고자 하는 원소의 순서에 따라 비교회수 결정
  - 정렬되어 있으므로 평균 비교 회수가 반으로 줄어든다
  - 시간 복잡도 : O(n)

> 이진 검색

- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색 위치 결정, 검색 진행

  - 목적 키를 찾을 때 까지 이진 검색을 순환적으로 반복 수행. 빠르게 검색 수행

- 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.

- 검색 과정
  - 자료의 중앙에 있는 원소를 고른다.
  - 중앙 원소의 값과 찾고자 하는 목표 값 비교
  - 목표 값이 중앙 원소의 값보다 작으면 왼쪽 반에 대해 새로 검색, 크다면 자료의 오른쪽 반에 대해 새로 검색
  - 반복

> 이진 검색 알고리즘

- 구현
  - 검색 범위의 시작점과 종료점을 이용하여 검색을 반복 수행한다.
  - 이진 검색의 경우, 자료에 삽입이나 삭제가 발생했을 때 배열의 상태를 항상 정렬상태로 유지하는 추가 작업이 필요하다.

## 인덱스

- 인덱스르 저장하는데 필요한 디스크 공간은 보통 테이블을 저장하는데 필요한 디스크 공간보다 작다.

- 배열을 사용한 인덱스

  - 데이터를 매번 정렬하면, 프로그램의 반응이 느려진다. 이러한 성능 저하 문제 해결을 위해 배열 인덱스 사용한다.

- 원본 데이터에 데이터가 삽입될 경우 상대적으로 크기가 작은 인덱스 배열을 정렬하기 때문에 속도가 빠르다.

> 선택 정렬

- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 위치를 교환

  - 셀렉션 알고리즘을 전체 자료에 적용

- 정렬 과정

  - 주어진 리스트 중 최소값 찾기
  - 그 값을 리스트의 맨 앞에 위치한 값과 교환
  - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 과정 반복

- 시간복잡도
  - O(n2)

> 선택 정렬 과정

1. 주어진 리스트에서 최소값 찾기
2. 리스트의 맨 앞에 위치한 값과 교환
3. 미정렬 리스트에서 최소값 찾기
4. 리스트의 맨 앞에 위치한 값과 교환
5. 반복
6. 미정렬원소가 하나 남은 상황에서 종료

```python
def selectionSort(a, N):
    for i in range(N-1):
        minIdx = i
        for j in range(i+1, N):
            if a[minIdx] > a[j]:
                minIdx = j
        a[i], a[minIdx] = a[minIdx], a[i]
```

> 셀렉션 알고리즘

- 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법

  - 최소값, 최대값, 중간값 알고리즘

- 선택 과정

  - 셀력선이 이루어지는 과정
    - 정렬 알고리즘을 이용하여 자료 정렬
    - 원하는 순서에 있는 원소 가져오기

- k번째로 작은 원소를 찾는 알고리즘
  - 1번부터 k번째까지 작은 원소등를 찾아 배열의 앞쪽으로 이동, k번째 반환.
