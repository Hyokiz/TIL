# 20220731 TIL

## 과목평가 대비 복습 01

> 프로그래밍의 정의

- 프로그램을 만드는 행위이다.
- 프로그램이란?
  - 특정 작업을 수행하는 일련의 명령어들의 모임

> 파이썬의 특징

- 인터프리터 언어
  - 소스 코드를 기계어로 변환할 때 통역하듯이 1줄씩 변환
  - 객체지향 프로그래밍
    - 현대 프로그래밍의 기본적인 설계 방법론으로 자리잡은 객체 지향 프로그래밍
    - 모든 것이 객체로 구현되어 있다.

> IDE란?

- 통합 개발 환경의 약자. 다양한 기능들을 모아 놓은 프로그램

> Jupyter Notebook

- 문법 학습을 위한 도구.

### 코드 작성법

> 들여쓰기

- Space Sensitive
  - 문장을 구분할 때 들여쓰기 사용
  - 4칸 or 1탭 (혼용하면 안된다.)

> 주석(Comment)

- 코드에 대한 설명
  - 코드를 이해하기 쉽게 하여 분석, 수정 용이
  - 코드에 영향 X, 개발자를 위한 것
- 가장 중요한 습관
  - 주석 습관은 중요하다.
    - 프로그램 속도 연관X, 용량X
- #이나 여러줄의 경우 (''', ''') 사용

> 주석의 장점

- 코드를 쉽게 이해할 수 있어서 코드 수정 및 협업에 유리

### 기초문법

> 변수

- 변수란
  - 데이터를 저장
  - 복잡한 값들을 쉽게 사용(추상화)
- 동일 변수에 다른 데이터를 언제든 할당할 수 있음.

> 추상화

- 코드의 가독성 증가
- 의미 단위로 작성 가능
- 코드 수정 용이

> 식별자

- 변수 이름 규칙
  - 식별자의 이름은 알파벳, 언더스코어, 숫자
  - 첫 글자에 숫자 X
  - 길이 제한 X, 대소문자 구별
  - 내장함수나 모듈 등의 이름 사용 X

### 연산자

> 산술연산자

- / == 나눗셈
- // == 몫
- \*\* == 거듭제곱

### 자료형

> 자료형 분류

- 수치형
  - int, float, complex(복소수)
- 문자열(Str)
- 불린형(Boolean)
- None

### 수치형

> 진수 표현

- 여러 진수 표현 가능
  - 2진수 : 0b
  - 8진수 : 0o
  - 16진수 : 0x

> 실수 연산시 주의할점(부동소수점)

- 실수의 값을 처리할 때 의도하지 않은 값이 나올 수 있음

```python
print(3.2 - 3.1) # 0.10000000000000009
print(1.2 - 1.1) # 0.09999999999999987
```

- 원인은 부동 소수점 때문
  - 근사값만 표시
  - 이런 과정에서 예상치 못한 결과가 나타남. 이런 증상을 Floating point rounding error

> 해결책

```python
a = 3.2 - 3.1
b = 1.2 - 1.1

# 1. 임의의 작은 수 활용
print(abs(a - b) <= 1e-10) # True

# 2. python 3.5 이상
import math
print(math.isclose(a, b)) # True
```

### 문자열 자료형

> 문자열 자료형의 정의

- 모든 문자는 str 타입
- 문자열은 작은따옴표(')나 큰따옴표(")를 활용하여 표기

> Escape sequence

- 역슬래시(backslash) 뒤에 특정 문자가 와서 특수한 기능을 하는 문자 조합
- \n : 줄바꿈
- \t : 탭
- \r : 캐리지 리턴
- \o : 널(Null)
- \\\ : \
- \' : 단일인용부호(')
- \" : 이중인용부호(")

> None

- 파이썬 자료형 중 하나

> 논리 연산자의 단축 평가

- 결과가 확실한 경우 두번째 값은 확인하지 않고 첫번째 값 반환
- and 연산에서 첫번째 값이 False인 경우 무조건 False >> 첫번째 값 반환
- or 연산자에서 첫번째 값이 True인 경우 무조건 True >> 첫번째 값 반환
- 0은 False, 1은 True

### 컨테이너

> 컨테이너란?

- 여러 개의 값을 담을 수 있는 것. 서로 다른 자료형 저장할 수 있음
- 컨테이너의 분류
  - 순서가 있는 데이터 vs 순서가 없는 데이터
  - 순서가 있다 != 정렬되어 있다.

> 컨테이너의 분류

- 크게 시퀀스형, 비시퀀스형(순서 유무)
- 가변형에는 리스트, 세트, 딕셔너리
- 불변형에는 튜플, 레인지, 정수, 실수, 문자열

### 시퀀스형

> 리스트

- 여러 개의 값을 순서가 있는 구조로 저장

> 리스트의 생성과 접근

- 리스트는 대괄호 혹은 list()를 통해 생성
  - 어떠한 자료형도 저장 가능. 리스트 안에 리스트도 가능
  - 내용변경 가능 >> mutable
  - 흔히 사용
- 시퀀스형이므로 인덱스를 통해 접근 가능

> 튜플

- 튜플은 여러 개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용.
- 내용변경 불가 >> immutable
- 항상 소괄호

> 튜플의 생성과 접근

- 소괄호 또는 tuple()
- immutable, 인덱스 접근 가능

> 튜플 생성 주의사항

- 단일 항목의 경우
  - 값 뒤에 쉼표를 붙여야 함
- 복수 항목의 경우
  - 마지막 쉼표는 없어도 되나, 넣는 것을 권장

> 튜플 대입(Tuple assignment)

- 튜플 대입이란?
  - 우변의 값을 좌변의 변수에 한 번에 할당하는 과정
- 튜플은 일반적으로 파이썬 내부에서 활용
  - 추후 함수에서 복수의 값을 반환할 때에도 활용

> 레인지(range)

- 숫자의 시퀀스를 나타내기 위해 사용
- 주로 반복문에서 사용

> 레인지 사용 방법

- 기본형 : range(n)
  - 0부터 n-1까지 숫자의 시퀀스
- 범위 지정 : range(n, m)
  - n부터 m-1까지 숫자의 시퀀스
- 범위 및 스텝 지정 : range(n, m, s)
  - n부터 m-1까지 s만큼 증가시키며 숫자의 시퀀스

> 슬라이싱 연산자

- 문자열의 특정 부분만 잘라낼 수 있음
- 콜론 기준 앞 문자는 포함, 뒷 문자는 미포함

### 비시퀀스형 컨테이너

> 셋(set)

- 중복되는 요소 없이, 순서에 상관없는 데이터들의 묶음
  - 데이터의 중복을 허용하지 않기 때문에 중복되는 원소가 있다면 하나만 저장
  - 인덱스를 통한 접근 X
- 수학에서의 집합
  - 집합 연산 가능
  - 중복된 값 존재 X
- 담고 있는 요소 삽입, 변경, 삭제 가능 >> mutable

> 셋 생성

- {}, set()
  - 빈 set을 만들기 위해서는 set() 반드시 활용
  - 순서가 없어 별도의 값 접근 X

> 셋 사용하기

- 중복된 값 쉽게 제거 가능
  - 순서가 중요한 경우 사용X

> 셋 연산자

- | : 합집합
- & : 교집합
- \- : 차집합
- ^ : 대칭차집합
- 여집합은 없음

> 딕셔너리

- 키와 값(key and value) 쌍으로 이뤄진 자료형
- Dictionary의 키
  - 키는 변경 불가능한 데이터(immutable)만 활용 가능
    - string, integer, float, boolean, tuple, range
- 각 키의 값
  - 어떠한 형태든 관계 없음

> 딕셔너리 생성

- {}, dict()
- key를 통해 value에 접근

### 형변환

> 형변환이란

- 파이썬에서 데이터 형태는 서로 변환 가능
- 암시적 형 변환(Implicit)
  - 사용자가 의도하지 않고, 내부적으로 자료형 변환
- 명시적 형 변환(Explicit)
  - 사용자가 특정 함수를 활용하여 의도적으로 자료형 변환

> 암시적 형 변환

- 파이썬 내부적으로 변환
  - bool
  - Numeric type(int, float)

> 명시적 형 변환

- int
  - str, float >> int
  - 형식에 맞는 문자열만
- float
  - str, int >> float
  - 형식에 맞는 문자열만
- str
  - int, float, list, tuple, dict >> str

## 과목평가 대비 복습 02

### 제어문

> 제어문

- 파이썬은 기본적으로 위에서 아래로 명령 수행
- 특정 상황에 따라 선택적으로 실행, 반복하는 제어 필요
- 제어문은 순서도로 표현 가능

### 조건문

- 조건문은 참/거짓을 판단할 수 있는 조건식과 함께 사용

### 반복문

> 반복문

- 특정 조건을 만족할 때까지 같은 동작을 계속 반복하고 싶을 때 사용

> 반복문의 종류

- while문
  - 종료 조건에 해당하는 코드를 통해 반복문을 종료시켜야 함
- for문
  - 반복가능한 객체를 모두 순회하면 종료(별도의 종료 조건 필요 없음)
- 반복 제어
  - break, continue, for-else

### While문

- while문은 조건식이 참인 경우 반복적으로 코드를 실행
- 종료 조건이 반드시 필요

> 복합 연산자

- 연산과 할당을 합쳐 놓은 것

### for문

- for문은 시퀀스(string, tuple, list, range)를 포함한 순회 가능한 객체의 요소를 모두 순회
  - 별도의 종료 조건X
- Iterable
  - 순회할 수 있는 자료형(string, list, dict, tuple, range, set 등)
  - 순회형 함수(range, enumerate)

> enumerate 순회

- enumerate()
  - 인덱스와 객체를 쌍으로 담은 열거형(enumerate) 객체 반환
    - (index, value)형태의 tuple로 구성된 열거 객체를 반환

### 반복문 제어

> 반복문 제어

- break
  - 반복문을 종료
- continue
  - continue 이후의 코드 블록은 수행하지 않고, 다음 반복 수행
- for-else
  - 끝까지 반복문을 실행한 이후에 else문 실행
    - break를 통해 중간에 종료되는 경우 else 문은 실행되지 않음
- pass
  - 아무것도 하지 않음(문법적으로 필요하지만, 할 일이 없을 때 사용)

### 함수

> 함수

- 함수를 왜 사용할까
  - Decomposition(분해)
  - Abstraction(추상화)

> 함수의 종류

- 함수는 크게 3가지
  - 내장 함수
    - 파이썬에 기본적으로 포함된 함수
  - 외장 함수
    - import 문을 통해 사용하며, 외부 라이브러리에서 제공하는 함수
  - 사용자 정의 함수
    - 직접 사용자가 만드는 함수

> 함수 기본 구조

- 선언과 호출(define & call)
- 입력(input)
- 문서화(docstring)
- 범위(scope)
- 결과값(output)

> print vs return

- 차이점
  - print를 사용하면 호출될 때마다 값이 출력됨
  - 데이터 처리를 위해서는 return 사용

### 함수의 입력

> parameter와 argument

- parameter : 함수를 정의할 때, 함수 내부에서 사용되는 변수
- argument : 함수를 호출할 때 넣어주는 값

> argument

- argument란?
  - 함수 호출 시 함수의 parameter를 통해 전달되는 값
  - argument는 소괄호 안에 할당 func_name(argument)
    - 필수 argument : 반드시 전달되어야 하는 argument
    - 선택 argument : 값을 전달하지 않아도 되는 경우는 기본값이 전달

> keyword arguments

- 직접 변수의 이름으로 특정 argument를 전달할 수 있음
- keyword argument 다음에 positional argument를 활용할 수 없음

```python
def add(x, y):
    return x + y

add(x=2, y=5)
add(2, y=5)
add(x=2, 5) >> Error 발생
```

> 가변 인자(\*args)

- 가변인자란?
  - 여러 개의 positional argument를 하나의 필수 parameter로 받아서 사용
- 가변 인자는 언제 사용?
  - 몇 개의 positional argument를 받을지 모르는 함수를 정의할 때 유용

> 패킹 / 언패킹

- 패킹

  - 여러 개의 데이터를 묶어서 변수에 할당하는 것

- 언패킹
  - 시퀀스 속의 요소들을 여러 개의 변수에 나누어 할당하는 것
  - 언패킹 시 변수의 개수와 할당하고자 하는 요소의 개수가 동일해야 함
  - 언패킹 시 왼쪽의 변수에 asterisk(\*)를 붙이면, 할당하고 남은 요소를 리스트에 담을 수 있음

> Asterisk(\*)와 가변 인자

- \*은 스퀸스 언패킹 연산자라고도 불리며, 말 그대로 시퀀스를 풀어헤치는 연산자
  - 주로 튜플이나 리스트를 언패킹하는데 사용
  - \*를 활용하여 가변 인자를 만들 수 있음

> 가변 키워드 인자(\*\*kwargs)

- 몇 개의 키워드 인자를 받을지 모르는 함수를 정의할 때 유용
- **kwargs는 딕셔너리로 묶여 처리되며, parameter에 **를 붙여 표현

### Python의 범위(Scope)

- 함수는 코드 내부에 local scope를 생성하며, 그 외의 공간인 global scope로 구분

> 이름 검색 규칙(Name Resolution)

- 파이썬에서 사용되는 이름(식별자)들은 이름공간(namespace)에 저장되어 있음
- LEGB Rule
  - Local scope : 지역 범위(현재 작업 중인 범위)
  - Enclosed scope : 지역 범위 한 단계 위 범위
  - Global scope : 최상단에 위치한 범위
  - Built-in-scope : 모든 것을 담고 있는 범위
- 함수 내에서는 바깥 Scope의 변수에 접근 가능하나 수정은 할 수 없음.

### 함수 응용

> lambda 함수

- 람다함수

  - 표현식을 계산한 결과값을 반환하는 함수로, 이름이 없는 함수여서 익명함수라고도 불림

- 특징

  - return 문 X
  - 간편 조건문 외 조건문이나 반복문 X

- 장점
  - 함수를 정의해서 사용하는 것보다 간결하게 사용 가능
  - def를 사용할 수 없는 곳에서도 사용 가능

> 재귀 함수(recursive function)

- 자기 자신을 호출하는 함수
- 무한한 호출 목표 X, 알고리즘 설계 및 구현에서 사용
  - 점화식
  - 변수의 사용이 줄어들며, 코드의 가독성 높아짐
- 1개 이상의 base case(종료상황)이 존재하고, 수렴하도록 작성

### 모듈

- 다양한 기능을 하나의 파일로 == 모듈
- 다양한 파일을 하나의 폴더로 == 패키지
- 다양한 패키지를 하나의 묶음으로 == 라이브러리
- 이것을 관리하는 관리자 == pip
- 패키지 활용 공간 == 가상환경

## 과목평가 대비 복습 03

### 데이터 구조

> 데이터 구조 활용

- 메서드 활용
  - 클래스 내부에 정의한 함수, 사실상 함수
  - 객체의 기능

> 문자열은 immutable인데 문자열 변경이 되는 이유

- 기존의 문자열을 변경하는게 아닌 변경된 문자열을 새롭게 만들어서 반환
  - replace, strip, title 등

### 얕은복사, 깊은복사

> 복사 방법

- 할당
- 얕은 복사
- 깊은 복사

> 할당

- 대입 연산자(=)
  - 해당 객체에 대한 객체 참조를 복사한다.

> 얕은 복사

- slice 연산자를 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사(다른 주소)

> 얕은 복사 주의사항

- 복사하는 리스트의 원소가 주소를 참조하는 경우
  - 원본과 얕은복사 둘다 변경

> 깊은 복사

- 하나만 변경

## 과목평가 대비 복습 04

### 객체지향 프로그래밍

> 객체지향 프로그래밍

- 프로그램을 여러 개의 독립된 객체들과 그 객체간의 상호작용으로 파악하는 프로그래밍 방법

- 기술 == 문제해결
- 문제해결을 위한 프로그래밍 == 객체지향 프로그래밍
- 절차지향 프로그래밍 == 호출 순서에 따라 진행이 된다.
- 프로그래밍은 저장과 처리로 나뉜다.
- 저장과 처리를 한번에 >> 함수
- 프로그램은 확장성이 고려되어야 한다. >> Style Guide
- 절차지향 프로그래밍의 단점 : 확장성이 떨어진다.
- 객체지향 프로그래밍 : 구조에 초점을 맞춤. 구조를 기준으로 프로그램이 실행된다.
- 클래스는 단지 도구일 뿐
- 객체의 세 가지 특징 : 역할, 책임, 협력
- 현실세계로 예를 들면
- 내 역할 : 교육생, 책임 : 교육받기, 협력 : 교수님과 협력하여 교육을 받음.
- 객체지향 프로그래밍은 객체끼리 요청과 응답을 통해 이루어짐

### 객체지향 프로그래밍의 구성 요소

- 추상화
- 상속
- 다형성
- 캡슐화
- 위 4가지가 사실 하나이다.

> 추상화

- 추상화 : 정확한 원리는 몰라도 사용은 가능함. ex 핸드폰, 컴퓨터를 사용해도 작동 원리는 모른다.
- 추상화 : 객체끼리 서로 소통할 때 역할과 책임에 맞는 주제를 협력할 때 원리는 상관 없이 요청만 하고 응답만 받으면 된다.

> 캡슐화

- 캡슐화 : 객체는 다른 객체의 내부에 간섭할 수 없다. 객체에게 자율성을 부여하기 때문
- 접근제어자 : public, protected, private
- getter :

> 다형성

- 다른 객체이더라도 요청했을 시 동일한 응답이 오면 괜찮다.

> 상속

- 상위 개념에 하위 개념에 상속되어있다.

---

### OOP

> 클래스와 객체

- 개별 객체를 하나의 타입으로 보는 것 == 추상화

> 기본 문법

- 클래스 정의, 인스턴스 생성, 메서드 호출, 속성

> 속성

- 타입/클래스의 객체들이 가지게 될 상태/데이터

> 클래스변수

- 클래스변수
  - 한 클래스의 모든 인스턴스가 공유하는 값

> 인스턴스와 클래스 간의 이름 공간

```python
class Person:
  counts = 0

  def __init__(self, name):
    self.name = name

p1 = Person("k")
p1.name
p1.counts
```

### 인스턴스메서드

- 변수를 함수 안에서 찾고 없으면 함수 밖에서 변수를 가지고 온다.

> 메서드

- 특정 데이터 타입/클래스의 객체에 공통적으로 적용 가능한 행위(함수)

> 생성자 메서드

- 인스턴스 객체가 생성될 때 자동으로 호출되는 메서드

> 매직 메서드

```python
class Person:
  def __init__(self, name):
    self.name = name

  def __str__(self): # 매직메서드
    return self.name # 매직메서드가 없을 시 Person object at id값이 나온다.

person1 = Person("sth")
print(person1) # sth

class Person:
  def __init__(self, name):
    self.name = name

  def __str__(self): # 매직메서드
    return self.name

  def __add__(self, other):
    return self.name + other.name

person1 = Person("sth")
person2 = Person("sone")
print(person1 + person2) # sthsone
```

> 소멸자

```python
class Person:
  counts = 0

  def __init__(self, name, age):
    self.name = name
    self.age = age

  def __str__(self): # 매직메서드
    return self.name + " " + str(self.age)

  def __del__(self):
    print("삭제되었습니다.")

person1 = Person("sth", 25)
person2 = person1
del person1
print(person2.name)
# sth
# 삭제되었습니다.
# del == 변수가 객체를 가르키는 참조값을 없애는 것.
# 왜 삭제되었습니다가 두번째에 나오나?
# person1의 참조값만 삭제한 것이기 때문에 person2의 값이 나오고 프로그램이 끝났기 때문에 "삭제되었습니다"가 출력된다.
```

### 클래스 메서드

- @classmethod 데코레이터를 사용하여 정의
- 호출 시, 첫번째 인자로 클래스(cls)가 전달됨
- 인스턴스 메서드는 클래스 변수 조회만 가능.

### 스태틱 메서드

- 유틸리티 함수
- 속성을 다루지 않고 단지 기능(행동)만을 하는 메서드를 사용할 때 사용
- 클래스 변수나 인스턴스 변수(self)를 사용하지 않을 때 @staticmethod 사용
- 고정된 값을 여러 번 출력할 때 사용

```python
class Person():
  counts = 0

  def __init__(self, name, age):
    self.name = name
    self.age = age

  def call_name(self):
    return f'대전 2반 {self.name} 입니다!'

  @staticmethod
  def hello():
    return '안녕하세요!'

person1 = Person("sth", 25)
print(person.call_name())
print(person1.hello())
```

### 캡슐화

> Public Member

- 언더바 없이 시작하는 메서드나 속성
- 어디서나 호출 가능

> Protected Member

- 언더바 1개로 시작하는 메서드나 속성
- Public과 Proviate의 가운데
- 느슨하게 제한하는 것
- 직접 접근하는 것을 거의 하지 않는다.(되는데 하면 안된다.)

> Private Member

- 언더바 2개로 시작하는 메서드나 속성
- 앞의 class 이름을 알면 접근할 수 있으나, 그렇게 하지 않는다.

> getter 메서드와 setter 메서드

- 객체지향의 패러다임 때문에 사용.
- getter : get. 가져오는 함수. 호출하는 것
- setter : set. 바꿔주는 함수.
- 자신이 직접 바꾸는 것이 아닌 getter, setter를 설정해서 각각의 함수에서 인자를 설정한다.
- 내가 직접 접근해서 값을 바꾸는 것이 아닌 조회할때는 getter, 수정할때는 setter.
- 객체에게 메세지를 보내는 것
- 직접 접근하는 것 처럼 보이게 하는것 = @property

### 에러와 예외

> 문법 에러(Syntax Error)

- SyntaxError가 발생하면 실행되지 않음
- 파일이름, 줄번호, ^를 통해 문제 발생 위치 표현
- 에러가 감지된 가장 앞의 위치를 가리키는 캐럿(caret)기호(^) 표시

> 예외

- 예상치 못한 상황 > 프로그램 실행 멈춤
- 실행 중 감지되는 에러들을 예외라고 부름
- 예외는 여러 타입으로 나타나고, 타입이 메시지의 일부로 출력
- 모든 내장 예외는 Exception Class를 상속받아 이뤄짐
- 사용자 정의 예외를 만들어 관리할 수 있음

> 예외 예시

- ZerodivisionError : 0으로 나누고자할때
- NameError : namespace 상에 이름이 없는 경우
- TypeError : 타입 불일치
- TypeError : argument 누락
- TypeError : argument 개수 초과
- TypeError : argument 타입 불일치
- ValueError : 타입은 올바르나 값이 적절하지 않거나 없는 경우
- IndexError : 인덱스가 존재하지 않거나 범위를 벗어나는 경우
- KeyError : 해당 키가 존재하지 않는 경우
- ModuleNotFoundError
- ImportError : Module은 있으나 존재하지 않는 클래스/함수를 가져오는 경우
- KeyboardInterrupt : 임의로 프로그램 종료했을 때
- IndentationError : 들여쓰기가 적절하지 않은 경우

### 예외 처리

- try / except 을 이용하여 예외처리 가능
- try
  - 오류가 발생할 가능성이 있는 코드 실행
  - 예외가 발생하지 않으면 except 없이 실행 종료
- except
  - 예외가 발생하면 except절이 실행
  - 예외 상황을 처리하는 코드를 받아서 적절한 조치 취함

> 예외 처리 종합

- try
  - 코드 실행
- except
  - try에서 예외 발생 시 실행
- else
  - try에서 예외가 발생하지 않으면 실행
- finally
  - 예외 발생 여부와 관계업이 항상 실행
